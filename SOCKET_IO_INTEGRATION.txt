================================================================================
SOCKET.IO REAL-TIME DATA INTEGRATION GUIDE
================================================================================

PROJECT: Jal Dharan - Groundwater Monitoring App
DATE: February 7, 2026
INTEGRATION: Socket.IO for Live Sensor Data Updates

================================================================================
1. OVERVIEW
================================================================================

The app now uses Socket.IO (WebSocket) for REAL-TIME sensor data updates from
the backend. This provides:

âœ… Live sensor data updates (water depth, flow rate, pH, TDS, etc.)
âœ… Automatic reconnection on network failures
âœ… Fallback to HTTP polling if Socket.IO unavailable
âœ… Zero lag monitoring of groundwater parameters
âœ… Offline state detection

================================================================================
2. DEPENDENCIES ADDED
================================================================================

pubspec.yaml additions:
- socket_io_client: ^2.0.0    (Socket.IO client library)
- provider: ^6.0.0            (State management for Socket.IO service)

Install with: flutter pub get

================================================================================
3. ARCHITECTURE
================================================================================

A. SOCKET SERVICE (NEW)
   File: lib/core/services/socket_service.dart

   - Handles Socket.IO connection lifecycle
   - Listens to 'sensor_update' event from backend
   - Provides callback system for UI updates
   - Singleton pattern (one instance app-wide)
   - Auto-reconnection on disconnect
   - Connection status tracking

B. MAIN APP (UPDATED)
   File: lib/main.dart

   - MultiProvider setup for Socket.IO service
   - Initializes Socket service when user logs in
   - Provides SocketService to all screens via Provider

C. HOME SCREEN (UPDATED)
   File: lib/presentation/screens/home/home_screen.dart

   - Listens to Socket.IO updates via Provider
   - Automatically updates UI on sensor_update event
   - Falls back to HTTP polling every 10 seconds
   - Removes socket listener on dispose

D. ANALYTICS SCREEN (UPDATED)
   File: lib/presentation/screens/analytics/analytics_screen.dart

   - Similar Socket.IO integration as HomeScreen
   - Updates prediction graphs in real-time
   - Maintains 7, 14, 30-day trend predictions

================================================================================
4. HOW IT WORKS
================================================================================

INITIALIZATION FLOW:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. User logs in â†’ MyApp StreamBuilder detects auth
2. MainNavigationScreen is shown
3. HomeScreen mounted â†’ Initializes SocketService
4. SocketService.initSocket() called
5. WebSocket connection established to backend
6. Simultaneously, HTTP polling starts to /mobile/dashboard every 10 seconds

7. Backend emits 'sensor_update' event with RAW SENSOR DATA ONLY:
   {
     "water_depth_m": 35.0,
     "flow_rate_L_min": 2.5,
     "tds_value": 250.0,
     "ph": 7.2,
     "voltage": 230.0,
     "pump_current_amps": 5.2,
     "timestamp": "2026-02-16T10:30:00"
   }

8. SocketService.onSensorData() listener triggered
9. Calls _onSensorDataReceived() in HomeScreen
10. Uses mergeWithSensorUpdate() to update sensor values only
11. Preserves calculated data from REST API
12. UI updates immediately with fresh sensor readings


REAL-TIME DATA FLOW (TWO SOURCES):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

LIVE SENSOR DATA (via Socket.IO):
ESP32 â†’ Backend â†’ Socket.IO Server â†’ App (WebSocket) [< 1 second latency]
                                          â†“
                                   SocketService
                                          â†“
                              HomeScreen/AnalyticsScreen
                                          â†“
                          mergeWithSensorUpdate()
                                          â†“
                              UI Update (setState)

CALCULATED DATA (via REST API):
Backend Database â†’ /mobile/dashboard â†’ App (HTTP polling every 10s)
                                        â†“
                           DashboardApiService
                                        â†“
                       GroundwaterData.fromJson()
                                        â†“
                    Update quality, motor status, predictions
                                        â†“
                              UI Update (setState)


CONNECTION STATES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

[IDLE] â†’ [CONNECTING] â†’ [CONNECTED] â† socket.onConnect()
                             â†“
                        Listening to 'sensor_update'
                             â†“
                        [DISCONNECTED] â† socket.onDisconnect()
                             â†“
                        [CONNECTING] (auto-reconnect)

================================================================================
5. USAGE IN SCREENS
================================================================================

EXAMPLE 1: HOME SCREEN LISTENER
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@override
void initState() {
  super.initState();

  // Initialize Socket
  Future.microtask(() {
    final socketService = Provider.of<SocketService>(context, listen: false);
    if (!socketService.isConnected && !socketService.isConnecting) {
      socketService.initSocket();
    }
    // Add listener for updates
    socketService.addSensorUpdateListener(_onSensorDataReceived);
  });
}

void _onSensorDataReceived(Map<String, dynamic> data) {
  final newData = GroundwaterData.fromJson(data);
  setState(() {
    _currentData = newData;
  });
}

@override
void dispose() {
  // Remove listener
  final socketService = Provider.of<SocketService>(context, listen: false);
  socketService.removeSensorUpdateListener(_onSensorDataReceived);
  super.dispose();
}


EXAMPLE 2: USING CONSUMER (ALTERNATIVE)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Consumer<SocketService>(
  builder: (context, socketService, child) {
    if (!socketService.isConnected) {
      return const Text('Waiting for live data...');
    }

    if (socketService.latestSensorData == null) {
      return const CircularProgressIndicator();
    }

    final data = socketService.latestSensorData!;
    return Text('Depth: ${data['sensor_data']['water_depth_m']} m');
  },
)

================================================================================
6. BACKEND SOCKET.IO SETUP
================================================================================

The backend Socket.IO server should:

1. Listen on same port as HTTP API (default: 8000)
2. Emit 'sensor_update' event when ESP32 sends sensor data
3. Connected clients receive real-time updates

BACKEND EVENT EMISSION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

io.emit('sensor_update', {
    'timestamp': '2026-01-25T15:52:00.123456',
    'sensor_data': {
        'water_depth_m': 35.0,
        'flow_rate_L_min': 2.5,
        'tds_value': 250.0,
        'ph': 7.2,
        'voltage': 230.0,
        'pump_current_amps': 5.2
    },
    'water_quality': {
        'quality_class': 'Good'
    },
    'motor_load': {
        'motor_status': 'Normal'
    },
    'water_extraction': {
        'current_session_m3': 28.0,
        'extracted_amount_m3': 280.0
    },
    'groundwater_trend': {
        'predicted_depth_7days': 34.8,
        'predicted_depth_14days': 34.5,
        'predicted_depth_30days': 34.0,
        'trend_30days': 'falling',
        'water_stress_level': 'moderate'
    },
    'weather_data': {
        'temp': 25.0,
        'condition': 'Haze',
        'description': 'haze',
        'icon': '50n',
        'rain_alert': 'Rain expected on: 2026-01-27'
    }
});

================================================================================
7. FALLBACK MECHANISM
================================================================================

If Socket.IO connection fails:

1. App continues with HTTP polling (fallback)
2. HomeScreen._fetchDashboardData() runs every 10 seconds
3. Updates UI with latest data from /mobile/dashboard endpoint
4. Socket.IO auto-reconnects when network recovers
5. No data loss - both mechanisms work together

Logs to check fallback:
- "âŒ Socket Connection Error" â†’ Socket.IO failed, using HTTP
- "ðŸ”Œ Reconnecting Socket..." â†’ Auto-reconnect triggered
- "âœ… Socket Connected" â†’ Live data now active

================================================================================
8. CONFIGURATION
================================================================================

MODIFY SOCKET SERVER URL:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

File: lib/core/services/socket_service.dart (line 35)

Change this line to match your backend IP:
final String _serverUrl = 'http://192.168.1.10:8000';

Or better: Use ApiConfig.baseUrl from api_config.dart


RECONNECTION SETTINGS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

In socket_service.dart, adjust these if needed:

.setReconnectionAttempts(double.infinity)  // Retry forever
.setReconnectionDelay(1000)                // Wait 1s before retry
.setReconnectionDelayMax(5000)             // Max wait 5s

================================================================================
9. DEBUGGING
================================================================================

ENABLE LOGS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

The app uses dart:developer for logging. View logs with:

flutter logs

Look for:
- "ðŸ”Œ Initializing Socket.IO connection"
- "âœ… Socket Connected"
- "âŒ Socket Disconnected"
- "ðŸ“¡ New Sensor Data Received"
- "ðŸ”„ HomeScreen received Socket update"

VISUAL INDICATORS:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

In future UI, you can show socket status:

socketService.isConnected ? "ðŸŸ¢ Live" : "ðŸ”´ Offline"

COMMON ISSUES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. "Connection refused"
   â†’ Backend not running or wrong IP in ApiConfig
   â†’ Check ApiConfig.baseUrl matches your backend server

2. "WebSocket connection timeout"
   â†’ Backend Socket.IO server not listening
   â†’ Ensure backend has Socket.IO running on port 8000

3. "No data updates after 30 seconds"
   â†’ Check backend is emitting 'sensor_update' events
   â†’ Verify firewall/network allows WebSocket connections

================================================================================
10. TESTING SOCKET.IO
================================================================================

MANUAL TESTING:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Run the app
2. Monitor logs: flutter logs
3. Look for: "âœ… Socket Connected" message
4. Change sensor values on hardware/backend
5. Watch for: "ðŸ“¡ New Sensor Data Received" in logs
6. UI should update automatically

STRESS TEST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Backend sends sensor_update every 1 second
2. App should process smoothly without lag
3. Check memory usage doesn't spike
4. Monitor battery drain on device

DISCONNECT TEST:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Disconnect device from WiFi
2. App should show offline state
3. Reconnect WiFi
4. Socket should auto-reconnect within 5 seconds
5. Data updates should resume

================================================================================
11. OFFLINE SYNCHRONIZATION (FUTURE)
================================================================================

For storing offline data:

1. Add sqflite or hive dependency
2. Create local database for sensor readings
3. Queue failed requests while offline
4. Sync when connection restored

Example flow:
- Sensor update received â†’ Save to local DB
- App offline â†’ Continue saving locally
- Reconnect â†’ Sync queued data to backend
- Backend processes sync batch

================================================================================
12. SECURITY NOTES
================================================================================

For production, implement:

1. Socket.IO authentication tokens
2. Verify JWT on each connection
3. Limit reconnection attempts per user
4. Rate limiting on sensor_update events
5. Validate data payload before processing
6. Encrypt sensitive sensor data in transit (TLS/SSL)

Backend example:
socket.on('connect', (socket) => {
  if (!socket.handshake.auth.token) {
    socket.disconnect(true);
    return;
  }
  // Verify JWT token
  const user = verifyToken(socket.handshake.auth.token);
  socket.userId = user.id;
});

================================================================================
13. PERFORMANCE CONSIDERATIONS
================================================================================

Network Bandwidth:
- Each sensor_update event ~500 bytes
- At 1Hz update rate: ~500 bytes/sec
- Minimal compared to video streaming

CPU Usage:
- Socket.IO: negligible impact
- JSON parsing: fast with Dart
- UI updates: only when data changes

Memory:
- SocketService singleton: ~1-2 MB
- Provider overhead: minimal
- No memory leaks if listeners properly cleaned

Battery:
- WebSocket more efficient than polling
- Less radio usage = longer battery life
- Estimated 10-15% improvement over HTTP polling

================================================================================
14. MIGRATION FROM HTTP POLLING
================================================================================

BEFORE (HTTP Polling):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Timer.periodic() every 10 seconds
- HTTP GET request each time
- Wait for response before updating
- Latency: 1-2 seconds
- Higher bandwidth usage

AFTER (Socket.IO):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Persistent WebSocket connection
- Server sends updates immediately
- Push model vs pull model
- Latency: 100-500ms
- Lower bandwidth usage
- True real-time monitoring

Hybrid approach (CURRENT):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
- Socket.IO primary (real-time)
- HTTP polling fallback (reliability)
- Best of both worlds
- HTTP only used if socket fails

================================================================================
15. FUTURE ENHANCEMENTS
================================================================================

Planned improvements:

1. âœ… Basic Socket.IO integration
2. ðŸ”œ Connection status badge in UI
3. ðŸ”œ Offline message queue
4. ðŸ”œ Local SQLite caching
5. ðŸ”œ Push notifications for alerts
6. ðŸ”œ Multiple device support
7. ðŸ”œ Data sync when coming online
8. ðŸ”œ Compression for large payloads
9. ðŸ”œ Custom binary protocol (less overhead)
10. ðŸ”œ End-to-end encryption

================================================================================
END OF SOCKET.IO INTEGRATION GUIDE
================================================================================

