================================================================================
SOCKET.IO IMPLEMENTATION - QUICK REFERENCE
================================================================================

For Developers: Quick lookups and code snippets

================================================================================
KEY CONCEPTS
================================================================================

1. RAW SENSOR DATA (Socket.IO)
   - Sent by: Backend Socket.IO server
   - Latency: < 1 second
   - Content: { water_depth_m, flow_rate_L_min, tds_value, ph, voltage, pump_current_amps, timestamp }
   - Method: GroundwaterData.fromSensorUpdate()
   - Use: Real-time gauge updates

2. CALCULATED DATA (REST API)
   - Sent by: /mobile/dashboard endpoint
   - Latency: 10-15 seconds
   - Content: Full response with quality, motor_status, predictions, weather
   - Method: GroundwaterData.fromJson()
   - Use: Complete data picture with insights

3. MERGE STRATEGY
   - Method: _currentData.mergeWithSensorUpdate(sensorData)
   - Purpose: Update sensors only, preserve calculations
   - Result: Fresh sensor values + recent predictions


================================================================================
CODE SNIPPETS
================================================================================

LISTENING TO SOCKET.IO:

void _onSensorDataReceived(Map<String, dynamic> data) {
  developer.log('üîÑ Received sensor update: $data');

  try {
    // Merge raw sensor data with existing calculated data
    final updatedData = _currentData.mergeWithSensorUpdate(data);

    if (mounted && _hasDataChanged(updatedData)) {
      setState(() => _currentData = updatedData);
      developer.log('‚úÖ UI updated with fresh sensor values');
    }
  } catch (e) {
    developer.log('‚ùå Error: $e');
  }
}


FETCHING CALCULATED DATA:

Future<void> _fetchDashboardData() async {
  if (!mounted) return;

  try {
    final data = await _apiService.fetchDashboardData();

    if (!mounted) return;

    setState(() {
      _currentData = data; // Complete replacement
      _isLoading = false;
    });
  } catch (e) {
    developer.log('API Error: $e');
  }
}


SETUP IN initState():

@override
void initState() {
  super.initState();
  _currentData = GroundwaterData.mockCurrentData();

  // 1. Setup Socket.IO
  Future.microtask(() {
    final socketService = Provider.of<SocketService>(context, listen: false);
    if (!socketService.isConnected && !socketService.isConnecting) {
      socketService.initSocket();
    }
    socketService.addSensorUpdateListener(_onSensorDataReceived);
  });

  // 2. Setup HTTP polling
  _startAutoRefresh();

  // 3. Initial API call
  _fetchDashboardData();
}


CLEANUP IN dispose():

@override
void dispose() {
  // Remove Socket listener
  Future.microtask(() {
    final socketService = Provider.of<SocketService>(context, listen: false);
    socketService.removeSensorUpdateListener(_onSensorDataReceived);
  });

  // Cancel polling timer
  _autoRefreshTimer.cancel();

  super.dispose();
}


================================================================================
DATA FLOW DIAGRAM
================================================================================

INITIAL LOAD:
  Screen.initState() ‚Üí _fetchDashboardData() ‚Üí API Call ‚Üí _currentData = full data

REAL-TIME UPDATES:
  SocketService.socket.on('sensor_update', (data) ‚Üí _onSensorDataReceived()
    ‚Üí _currentData.mergeWithSensorUpdate(data) ‚Üí setState() ‚Üí UI refresh

PERIODIC UPDATES (every 10 seconds):
  Timer.periodic() ‚Üí _fetchDashboardData() ‚Üí API Call ‚Üí _currentData = new full data


================================================================================
CHECKING IF SOCKET IS CONNECTED
================================================================================

// In any screen:
Consumer<SocketService>(
  builder: (context, socketService, child) {
    if (socketService.isConnected) {
      // Socket is active - real-time updates working
      return Text('Live: ‚úÖ');
    } else if (socketService.isConnecting) {
      return Text('Connecting...');
    } else {
      // Fallback to HTTP polling only
      return Text('Offline mode (polling only)');
    }
  },
)


================================================================================
DEBUGGING CHECKLIST
================================================================================

Socket.IO Not Connecting:
  [ ] Is ApiConfig.baseUrl correct?
  [ ] Is backend server running?
  [ ] Is Socket.IO server on port 8000?
  [ ] Check logs for "Socket Error"
  [ ] Verify firewall allows port 8000

Data Not Updating:
  [ ] Can you see "üì° New Sensor Data Received" in logs?
  [ ] Is Socket listener properly initialized?
  [ ] Check _onSensorDataReceived() is being called
  [ ] Verify mergeWithSensorUpdate() logic
  [ ] Check mounted flag before setState()

Calculated Values Old:
  [ ] Is /mobile/dashboard endpoint responding?
  [ ] Is _startAutoRefresh() timer running?
  [ ] Check "Fetching dashboard data" in logs
  [ ] Verify network connectivity
  [ ] Check API error messages

UI Not Updating:
  [ ] Check mounted flag before setState()
  [ ] Verify _hasDataChanged() logic
  [ ] Check if values actually changed
  [ ] Look for "UI updated" log messages
  [ ] Verify state is being set correctly


================================================================================
CONFIGURATION LOCATIONS
================================================================================

API Endpoint Configuration:
  File: lib/core/config/api_config.dart
  Line: static const String baseUrl = 'http://192.168.31.230:8000';

Socket Service Setup:
  File: lib/core/services/socket_service.dart
  Method: void initSocket()

Home Screen Integration:
  File: lib/presentation/screens/home/home_screen.dart
  Methods: _onSensorDataReceived(), _startAutoRefresh()

Analytics Screen Integration:
  File: lib/presentation/screens/analytics/analytics_screen.dart
  Methods: _onSensorDataReceived(), _startAutoRefresh()

Data Model:
  File: lib/core/models/groundwater_data.dart
  Methods: fromJson(), fromSensorUpdate(), mergeWithSensorUpdate()


================================================================================
EXPECTED LOG MESSAGES
================================================================================

STARTUP (connection established):
  ‚úÖ Socket Connected to backend
  üì° Fetching dashboard data from API
  ‚úÖ Dashboard data fetched successfully

DURING OPERATION (real-time updates):
  üì° New Sensor Data Received: {...}
  üîÑ HomeScreen received Socket sensor update: {...}
  ‚úÖ HomeScreen UI updated with fresh sensor values from Socket

PERIODIC (every 10 seconds):
  üì° Fetching dashboard data from API
  ‚úÖ Dashboard data fetched successfully

ERRORS (something wrong):
  ‚ùå Socket Error: ...
  ‚ùå Socket Disconnected from backend
  ‚ùå Error parsing socket data: ...
  ‚ùå Dashboard API Error: ...


================================================================================
TESTING SOCKET.IO LOCALLY
================================================================================

1. Verify Backend is Running:
   curl -v http://192.168.31.230:8000/

2. Test Sensor Endpoint:
   curl http://192.168.31.230:8000/mobile/dashboard?user_id=test_user

3. Monitor Live Logs:
   flutter logs --grep="Socket\|sensor_update\|Dashboard"

4. Test with Mock Backend:
   - Comment out socketService.initSocket() in HomeScreen
   - Use GroundwaterData.mockCurrentData() for testing
   - This removes Socket.IO dependency for development

5. Simulate Sensor Updates:
   - Manually call _onSensorDataReceived() with test data
   - Verify mergeWithSensorUpdate() works correctly


================================================================================
COMMON CHANGES YOU MIGHT MAKE
================================================================================

Change Polling Interval (from 10s to 5s):
  In home_screen.dart:
  static const Duration _refreshInterval = Duration(seconds: 5);

Change API Base URL (for different backend):
  In api_config.dart:
  static const String baseUrl = 'http://YOUR_NEW_IP:8000';

Add More Screens with Socket Listener:
  1. Copy pattern from HomeScreen._onSensorDataReceived()
  2. Call socketService.addSensorUpdateListener() in initState()
  3. Call socketService.removeSensorUpdateListener() in dispose()

Handle New Sensor Fields:
  1. Add field to GroundwaterData class
  2. Update fromJson() factory
  3. Update mergeWithSensorUpdate() method
  4. Use in UI widgets


================================================================================
PERFORMANCE TIPS
================================================================================

1. Use _hasDataChanged() Before setState()
   Prevents unnecessary UI rebuilds

2. Check mounted Before setState()
   Prevents errors after widget disposal

3. Remove Socket Listeners in dispose()
   Prevents memory leaks

4. Use Immutable Data (return new instances)
   Easier to compare and debug

5. Log Important Events
   Use developer.log() for debugging (doesn't show to users)

6. Keep Socket Listeners Lightweight
   Do heavy processing in _fetchDashboardData()


================================================================================
MIGRATION GUIDE (Adding Socket.IO to Existing Screen)
================================================================================

Step 1: Add Socket Listener in initState()
  Future.microtask(() {
    final socketService = Provider.of<SocketService>(context, listen: false);
    socketService.addSensorUpdateListener(_onSensorDataReceived);
  });

Step 2: Implement Callback
  void _onSensorDataReceived(Map<String, dynamic> data) {
    final updatedData = _currentData.mergeWithSensorUpdate(data);
    if (mounted && _hasDataChanged(updatedData)) {
      setState(() => _currentData = updatedData);
    }
  }

Step 3: Remove Listener in dispose()
  Future.microtask(() {
    final socketService = Provider.of<SocketService>(context, listen: false);
    socketService.removeSensorUpdateListener(_onSensorDataReceived);
  });

Step 4: Test
  - Check logs for "Socket Connected"
  - Verify sensor updates appear
  - Confirm UI updates in real-time


================================================================================
QUICK TROUBLESHOOTING TREE
================================================================================

App starts but no data:
  ‚Üí Check API call in initState()
  ‚Üí Verify mock data fallback works

Socket shows as not connected:
  ‚Üí Check baseUrl in api_config.dart
  ‚Üí Verify backend is running
  ‚Üí Check firewall/network

Data updates then stops:
  ‚Üí Socket disconnected (check logs)
  ‚Üí API calls failing (check API endpoint)
  ‚Üí Screen disposed (check dispose() cleanup)

UI updates are slow:
  ‚Üí API polling too slow (increase frequency)
  ‚Üí _hasDataChanged() not working (check logic)
  ‚Üí Heavy computations in setState() (move to service)

================================================================================

