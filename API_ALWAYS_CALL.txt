â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    âœ… API CALL BEHAVIOR UPDATED âœ…
              Always Call API, Update Only When Data Changes
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHAT WAS CHANGED:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

OLD BEHAVIOR:
  - API called only once in initState()
  - Every time screen is visited, it showed cached data
  - User had to manually refresh to get new data

NEW BEHAVIOR:
  - API called every time the screen is visited/becomes visible âœ…
  - Data only updates UI when values actually change âœ…
  - User sees instant loading state while fetching fresh data âœ…
  - Previous values remain visible while loading âœ…

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

HOW IT WORKS NOW:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£  User Opens HomeScreen
    â””â”€ initState() â†’ Loads mock data (instant display)
    â””â”€ UI shows immediately

2ï¸âƒ£  Screen Becomes Visible
    â””â”€ didChangeDependencies() is called
    â””â”€ _fetchDashboardData() starts
    â””â”€ Loading state = true

3ï¸âƒ£  API Request Sent
    â””â”€ GET /mobile/dashboard called
    â””â”€ Mock data still visible while loading

4ï¸âƒ£  API Response Received
    â””â”€ _hasDataChanged() checks if any values are different
    â””â”€ If data changed â†’ UI updates with new values âœ…
    â””â”€ If data same â†’ Only stops loading, no UI rebuild

5ï¸âƒ£  User Navigates Away
    â””â”€ Screen is removed from tree

6ï¸âƒ£  User Returns to HomeScreen
    â””â”€ didChangeDependencies() called again âœ…
    â””â”€ API call happens again âœ… (Fresh data fetch)
    â””â”€ Cycle repeats

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY METHOD: didChangeDependencies()
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What it does:
  - Called whenever the widget's dependencies change
  - Called when screen becomes visible after navigation
  - More efficient than constantly polling

Why use it instead of initState():
  - initState() runs only once when widget is created
  - didChangeDependencies() runs every time dependencies change
  - Perfect for "update when screen is visited" requirement

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CHANGE DETECTION: _hasDataChanged()
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

What it checks:
  âœ“ currentDepth - Water level (m)
  âœ“ flowRate - Flow rate (L/min)
  âœ“ tdsLevel - TDS value (ppm)
  âœ“ phLevel - pH level
  âœ“ voltage - Voltage (V)
  âœ“ current - Current (A)
  âœ“ motorStatus - Pump status
  âœ“ currentSession - Current extraction (mÂ³)
  âœ“ estimatedExtraction - Estimated extraction (mÂ³)
  âœ“ qualityStatus - Water quality
  âœ“ lastUpdated - Timestamp

If ANY of these values are different:
  â†’ UI updates with new data

If ALL values are the same:
  â†’ Only stops loading state
  â†’ No unnecessary UI rebuild

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DATA FLOW DIAGRAM:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Navigation Stack:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Screen A                                        â”‚
â”‚ (User navigates to HomeScreen)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HomeScreen                                      â”‚
â”‚ initState() â†’ Load mock data                    â”‚
â”‚ didChangeDependencies() â†’ Call API              â”‚
â”‚                                                  â”‚
â”‚ API Response:                                   â”‚
â”‚  - If data changed â†’ setState() â†’ UI updates    â”‚
â”‚  - If data same â†’ setState(loading=false) only  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User navigates to Screen B                      â”‚
â”‚ HomeScreen.dispose() called                     â”‚
â”‚ (Widget removed from tree)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User navigates back to HomeScreen               â”‚
â”‚ didChangeDependencies() called again âœ…         â”‚
â”‚ NEW API call happens âœ…                         â”‚
â”‚                                                  â”‚
â”‚ API Response:                                   â”‚
â”‚  - Check data changes                          â”‚
â”‚  - Update only if different                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CODE IMPLEMENTATION:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@override
void didChangeDependencies() {
  super.didChangeDependencies();
  // Call API whenever screen becomes visible
  _fetchDashboardData();  // âœ… Always called when screen is visited
}

Future<void> _fetchDashboardData() async {
  if (!mounted) return;

  setState(() {
    _isLoading = true;
    _errorMessage = null;
  });

  try {
    final data = await _apiService.fetchDashboardData();

    if (!mounted) return;

    // Only update if data has changed
    if (_hasDataChanged(data)) {
      setState(() {
        _currentData = data;  // âœ… Update only if different
        _isLoading = false;
      });
    } else {
      // Data hasn't changed
      setState(() {
        _isLoading = false;  // âœ… Stop loading but don't rebuild UI
      });
    }
  } catch (e) {
    if (!mounted) return;

    setState(() {
      _errorMessage = e.toString();
      _isLoading = false;
    });

    // Show error with retry
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to load data: $e'),
          backgroundColor: Colors.red,
          action: SnackBarAction(
            label: 'Retry',
            onPressed: _fetchDashboardData,
          ),
        ),
      );
    }
  }
}

bool _hasDataChanged(GroundwaterData newData) {
  return _currentData.currentDepth != newData.currentDepth ||
         _currentData.flowRate != newData.flowRate ||
         // ... check all other fields ...
         _currentData.lastUpdated != newData.lastUpdated;
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BENEFITS OF THIS APPROACH:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… Always Fresh Data
   - API called every time screen is visited
   - User always sees latest data

âœ… Efficient UI Updates
   - Only rebuilds if data actually changed
   - No unnecessary re-renders
   - Smooth user experience

âœ… Better Performance
   - didChangeDependencies() is more efficient than Timer
   - Only runs when needed
   - No memory leaks

âœ… User Friendly
   - Loading state visible during fetch
   - Mock data shown while loading
   - Retry button on error
   - No blocking UI

âœ… Data Consistency
   - Timestamp always updated
   - User knows when data was last fetched
   - Clear loading indicator

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

LIFECYCLE BREAKDOWN:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

When HomeScreen widget is created:

1. initState()
   â””â”€ Called once
   â””â”€ Initialize TabController
   â””â”€ Load mock data
   â””â”€ Does NOT call API

2. didChangeDependencies()
   â””â”€ Called automatically by Flutter
   â””â”€ Called when dependencies change
   â””â”€ Called when screen becomes visible
   â””â”€ Calls _fetchDashboardData() âœ…

3. _fetchDashboardData()
   â””â”€ Shows loading state
   â””â”€ Makes API request
   â””â”€ Checks if data changed
   â””â”€ Updates UI only if needed

4. dispose()
   â””â”€ Called when widget is removed
   â””â”€ Cleans up resources
   â””â”€ TabController.dispose()

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEHAVIOR SCENARIOS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Scenario 1: User Opens App
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. HomeScreen opens
2. initState() â†’ mock data shown
3. didChangeDependencies() â†’ API call starts
4. (Mock data still visible)
5. API returns with real data
6. _hasDataChanged() â†’ YES
7. UI updates with real data âœ…

Scenario 2: User Navigates Away & Back
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. User is on HomeScreen (showing real data)
2. User taps bottom nav â†’ Goes to another screen
3. HomeScreen.dispose() called
4. User taps "Home" again in nav
5. didChangeDependencies() â†’ API call starts âœ… (NEW CALL)
6. Previous data still visible
7. API returns
8. _hasDataChanged() â†’ If values changed, update UI
9. If values same â†’ Just stop loading âœ…

Scenario 3: User Quickly Navigates Back & Forth
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Home screen
2. Go to Settings
3. Come back to Home â†’ API call #1 âœ…
4. Go to Gamification
5. Come back to Home â†’ API call #2 âœ…
6. Go to Knowledge Hub
7. Come back to Home â†’ API call #3 âœ…
(Each time = fresh API call)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TESTING THE BEHAVIOR:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Test 1: Check API is called every time
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Open app â†’ See mock data
2. Wait for API response
3. Check console â†’ "Dashboard API Error:" should not appear if success
4. Go to another screen
5. Come back to Home
6. Should see loading indicator briefly
7. Data updates (or stays same if no change)

Test 2: Check data updates only when different
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Open HomeScreen
2. Wait for data to load
3. Navigate away and back
4. If backend returns SAME data:
   âœ… Loading stops but UI doesn't flicker
   âœ… Values stay same
5. If backend returns DIFFERENT data:
   âœ… UI updates smoothly
   âœ… Only changed values update

Test 3: Check loading state
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. Open HomeScreen
2. Wait 1 second
3. Check if loading spinner appears briefly
4. Data updates
5. Loading spinner disappears

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMPARISON: OLD vs NEW
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Feature                    OLD              NEW
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
API called at             initState()      didChangeDependencies()
How often                 Once only        Every visit âœ…
Data refresh needed       Manual (Retry)   Automatic âœ…
Shows loading state       Yes              Yes (every visit) âœ…
Updates only if changed   No               Yes âœ…
Efficient updates         No               Yes âœ…

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SUMMARY:
â•â•â•â•â•â•â•â•

âœ… API is now called every time the HomeScreen is visited
âœ… UI updates only when values actually change
âœ… Loading state shows during fetch
âœ… Previous data visible while loading
âœ… No unnecessary rebuilds
âœ… Smooth user experience

Your app will now always fetch fresh data while being smart about
updates! ğŸš€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
