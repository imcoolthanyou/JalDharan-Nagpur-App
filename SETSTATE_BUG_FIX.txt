â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                        âœ… BUG FIX: setState() After Dispose
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ISSUE:
â•â•â•â•â•â•

E/flutter: Unhandled Exception: setState() called after dispose():
  _HomeScreenState#531b8(lifecycle state: defunct, not mounted)

CAUSE:
â•â•â•â•â•â•

The `_fetchDashboardData()` method was calling `setState()` after the API
response returned, even if the HomeScreen widget had been disposed/removed
from the widget tree.

Timeline:
1. User opens HomeScreen
2. _fetchDashboardData() starts API call
3. User navigates away from HomeScreen
4. Widget is disposed
5. API response arrives
6. setState() is called on disposed widget âŒ ERROR

SOLUTION:
â•â•â•â•â•â•â•â•â•

Check the `mounted` property before calling `setState()`.

When a widget is removed from the tree:
- mounted = false
- setState() calls are ignored
- No error is thrown

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CODE CHANGES:
â•â•â•â•â•â•â•â•â•â•â•â•â•

BEFORE (âŒ BUGGY):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Future<void> _fetchDashboardData() async {
  setState(() {
    _isLoading = true;
    _errorMessage = null;
  });

  try {
    final data = await _apiService.fetchDashboardData();
    setState(() {  // âŒ Can be called after dispose
      _currentData = data;
      _isLoading = false;
    });
  } catch (e) {
    setState(() {  // âŒ Can be called after dispose
      _errorMessage = e.toString();
      _isLoading = false;
    });
    // ... rest of code
  }
}

AFTER (âœ… FIXED):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Future<void> _fetchDashboardData() async {
  if (!mounted) return;  // âœ… Early return if disposed

  setState(() {
    _isLoading = true;
    _errorMessage = null;
  });

  try {
    final data = await _apiService.fetchDashboardData();

    if (!mounted) return;  // âœ… Early return if disposed

    setState(() {
      _currentData = data;
      _isLoading = false;
    });
  } catch (e) {
    if (!mounted) return;  // âœ… Early return if disposed

    setState(() {
      _errorMessage = e.toString();
      _isLoading = false;
    });
    // ... rest of code
  }
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY POINTS:
â•â•â•â•â•â•â•â•â•â•â•â•

1. CHECK MOUNTED BEFORE setState()
   - mounted is a boolean property of State
   - mounted = true: widget is in widget tree
   - mounted = false: widget has been disposed

2. EARLY RETURN PATTERN
   if (!mounted) return;  // Safety check
   setState(() { ... });  // Safe to call

3. TIMING IS CRITICAL
   - Check mounted immediately after async operation
   - API response can take seconds
   - User might navigate away during that time

4. PREVENTS MEMORY LEAKS
   - Avoids keeping disposed widgets in memory
   - Prevents unnecessary state updates
   - Cleans up resources properly

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BEST PRACTICE PATTERN:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

For ANY async operation in StatefulWidget:

Future<void> myAsyncMethod() async {
  if (!mounted) return;  // âœ… First check

  setState(() { /* ... */ });  // Initial state

  try {
    final result = await someAsyncOperation();

    if (!mounted) return;  // âœ… Check before setState
    setState(() { /* ... */ });

  } catch (e) {
    if (!mounted) return;  // âœ… Check in error handler
    setState(() { /* ... */ });
  }
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

WHERE THIS FIX WAS APPLIED:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

File: lib/presentation/screens/home/home_screen.dart
Method: _fetchDashboardData()
Lines: 42-85

Three `mounted` checks were added:
1. At the start of the method
2. After API call completes (before setState)
3. In catch block (before setState)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TESTING THE FIX:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

To verify the fix works:

1. Open the app
2. HomeScreen should display with mock data
3. Navigate to another screen within 2 seconds (before API response)
4. Go back to HomeScreen
5. âŒ BEFORE: Error in console
6. âœ… AFTER: No error, clean navigation

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SIMILAR FIXES TO CHECK:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

If you have other screens with API calls, apply the same pattern:

Common places:
- Any async function that calls setState()
- API calls in initState()
- Network requests
- Image loading
- File operations

Example screens to check:
â–¡ lib/presentation/screens/home/home_screen.dart âœ… FIXED
â–¡ Other screens with API calls

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ADDITIONAL IMPROVEMENTS:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

If you want to add more robustness:

1. Add Timeout
   final data = await _apiService.fetchDashboardData()
     .timeout(Duration(seconds: 10),
       onTimeout: () => throw Exception('Timeout'));

2. Add Retry Logic
   int retries = 0;
   while (retries < 3) {
     try {
       return await _apiService.fetchDashboardData();
     } catch (e) {
       retries++;
       if (retries >= 3) rethrow;
       await Future.delayed(Duration(seconds: 2));
     }
   }

3. Add Loading Indicator
   - Show CircularProgressIndicator while loading
   - Replace mock data UI with loading skeleton

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SUMMARY:
â•â•â•â•â•â•â•â•â•

âœ… Issue: setState() called after dispose
âœ… Root Cause: Async operation completing after widget disposal
âœ… Solution: Check mounted before each setState()
âœ… Applied: In _fetchDashboardData() method
âœ… Result: No more errors when navigating away during API call

Your app should now run without this error! ğŸš€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
